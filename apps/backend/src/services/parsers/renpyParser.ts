/**
 * Ren'Py Parser for Visual Novel games (.rpy files)
 * Extracts dialogue, menu options, and other text
 */

import type { ParsedEntry } from './jsonParser';

export class RenPyParser {
  /**
   * Parse Ren'Py script file
   */
  parse(content: string, filename: string): ParsedEntry[] {
    const entries: ParsedEntry[] = [];
    const lines = content.split('\n');

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const lineNumber = i + 1;

      // Extract dialogue: character "text"
      const dialogueMatch = line.match(/^\s*(\w+)\s+"([^"]+)"/);
      if (dialogueMatch) {
        entries.push({
          context: 'dialogue',
          originalText: dialogueMatch[2],
          lineNumber,
          sourceFile: filename,
          metadata: { character: dialogueMatch[1] },
        });
        continue;
      }

      // Extract narrator text: "text"
      const narratorMatch = line.match(/^\s+"([^"]+)"/);
      if (narratorMatch && !dialogueMatch) {
        entries.push({
          context: 'narrator',
          originalText: narratorMatch[1],
          lineNumber,
          sourceFile: filename,
        });
        continue;
      }

      // Extract menu options: menu:\n    "option text"
      if (line.trim().startsWith('"') && line.includes(':')) {
        const menuMatch = line.match(/^\s+"([^"]+)":/);
        if (menuMatch) {
          entries.push({
            context: 'menu',
            originalText: menuMatch[1],
            lineNumber,
            sourceFile: filename,
          });
        }
      }

      // Extract define statements: define character_name = "Display Name"
      const defineMatch = line.match(/^\s*define\s+\w+\s*=\s*"([^"]+)"/);
      if (defineMatch) {
        entries.push({
          context: 'define',
          originalText: defineMatch[1],
          lineNumber,
          sourceFile: filename,
        });
      }
    }

    return entries;
  }

  /**
   * Export translations back to Ren'Py format
   */
  export(
    entries: Array<{
      originalText: string;
      currentTranslation?: string;
      context?: string;
      lineNumber?: number;
      metadata?: any;
    }>,
    originalContent?: string
  ): string {
    if (!originalContent) {
      // Generate new file from entries
      return this.generateNewFile(entries);
    }

    // Replace in original file
    return this.replaceInOriginal(entries, originalContent);
  }

  /**
   * Generate new Ren'Py file from entries
   */
  private generateNewFile(
    entries: Array<{
      originalText: string;
      currentTranslation?: string;
      context?: string;
      metadata?: any;
    }>
  ): string {
    let output = '# Generated by Glossary Tool\n\n';

    entries.forEach((entry) => {
      const translation = entry.currentTranslation || entry.originalText;

      switch (entry.context) {
        case 'dialogue':
          const character = entry.metadata?.character || 'narrator';
          output += `${character} "${translation}"\n`;
          break;
        case 'narrator':
          output += `"${translation}"\n`;
          break;
        case 'menu':
          output += `    "${translation}":\n`;
          break;
        case 'define':
          output += `define ${entry.metadata?.varName || 'var'} = "${translation}"\n`;
          break;
        default:
          output += `"${translation}"\n`;
      }
    });

    return output;
  }

  /**
   * Replace translations in original file
   */
  private replaceInOriginal(
    entries: Array<{
      originalText: string;
      currentTranslation?: string;
      lineNumber?: number;
    }>,
    originalContent: string
  ): string {
    const lines = originalContent.split('\n');

    entries.forEach((entry) => {
      if (entry.lineNumber && entry.currentTranslation) {
        const lineIndex = entry.lineNumber - 1;
        if (lineIndex >= 0 && lineIndex < lines.length) {
          const line = lines[lineIndex];
          // Replace the text content while keeping structure
          lines[lineIndex] = line.replace(
            new RegExp(`"${this.escapeRegex(entry.originalText)}"`),
            `"${entry.currentTranslation}"`
          );
        }
      }
    });

    return lines.join('\n');
  }

  /**
   * Escape special regex characters
   */
  private escapeRegex(str: string): string {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}

export const renpyParser = new RenPyParser();