/**
 * üß† AI TRANSLATOR v2.6.9 ‚Äì APPROVAL MODE (Full Release)
 * ------------------------------------------------------
 * ‚úÖ Multi-language translation (EN/JP/ZH/KO/VI)
 * ‚úÖ Safe async batch
 * ‚úÖ Auto Extract Terms (Full Target for approval)
 * ‚úÖ Approve / Clean / Merge Glossary workflow
 * Author: Pinus & ChatGPT
 * Date: 2025-10-27
 */

// ====================== CONFIG ======================
const USE_MOCK_AI_ONLY = false;
const HARD_MODE = true;
const MAX_ROWS_PER_RUN = 100;
const MODEL = 'openai/gpt-5-mini';

// Get API Key securely
function getApiKey() {
  const key = PropertiesService.getScriptProperties().getProperty('OPENROUTER_API_KEY');
  if (!key) throw new Error('‚ö†Ô∏è Missing OPENROUTER_API_KEY. Add it in Script Properties.');
  return key;
}

// ====================== 1Ô∏è‚É£ TRANSLATION ======================
function translatePendingRows() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Translations');
  const glossary = ss.getSheetByName('Glossary').getDataRange().getValues();
  const data = sheet.getDataRange().getValues();

  const pending = [];
  for (let i = 1; i < data.length; i++) if (data[i][4] === 'Pending' && data[i][2]) pending.push(i);
  if (pending.length === 0) return SpreadsheetApp.getUi().alert('‚úÖ No Pending rows.');

  const props = PropertiesService.getScriptProperties();
  const lastIndex = Number(props.getProperty('lastRowIndex')) || 0;
  const slice = pending.slice(lastIndex, lastIndex + MAX_ROWS_PER_RUN);

  const start = Date.now();
  const batchTexts = slice.map(i => {
  const context = data[i][1] ? `[Context: ${data[i][1]}] ` : '';
  return `${context}${data[i][2]}`;
});
  const batches = createAdaptiveBatches(batchTexts, slice);

  for (const b of batches) processBatch(b.texts, b.rows, glossary, sheet);

  props.setProperty('lastRowIndex', lastIndex + slice.length);
  if (lastIndex + slice.length >= pending.length) props.deleteProperty('lastRowIndex');

  const t = ((Date.now() - start) / 1000).toFixed(1);
  SpreadsheetApp.getUi().alert(`‚ö° Translated ${slice.length} rows in ${t}s.`);
}

function createAdaptiveBatches(texts, rows) {
  const res = [];
  let curT = [], curR = [], len = 0;
  for (let i = 0; i < texts.length; i++) {
    const l = texts[i].length;
    if (len + l > 2000 || curT.length >= 15) {
      res.push({ texts: curT, rows: curR });
      curT = []; curR = []; len = 0;
    }
    curT.push(texts[i]); curR.push(rows[i]); len += l;
  }
  if (curT.length) res.push({ texts: curT, rows: curR });
  return res;
}

function processBatch(texts, rows, glossary, sheet) {
  const combined = texts.map((t,i)=>`${i+1}. ${t}`).join('\n');
  const filteredGlossary = filterGlossaryForText(glossary, combined);
  let translations = '';

  if (!USE_MOCK_AI_ONLY) translations = callBatchAI(combined, filteredGlossary);
  else translations = texts.map(t=>mockTranslateWithGlossary(t,filteredGlossary)).join('\n');

  const lines = translations.split('\n').filter(x=>x.trim()!=='');
  for (let i = 0; i < rows.length && i < lines.length; i++) {
    sheet.getRange(rows[i]+1, 4).setValue(lines[i]);
    sheet.getRange(rows[i]+1, 5).setValue('Translated');
  }
}

// ====================== FIXED: TRUE HARD MODE VIETNAMESE TRANSLATION ======================
function callBatchAI(text, glossary) {
  const glossText = buildGlossaryText(glossary);

  // ‚úÖ Song ng·ªØ ƒë·ªÉ model hi·ªÉu ƒë√∫ng √Ω
  const systemPrompt = `
You are a professional localization translator specialized in East Asian languages (Japanese, Chinese, Korean).
Translate everything **into natural Vietnamese** with correct grammar and tone.
Never leave untranslated words, never add explanations.

---
B·∫°n l√† chuy√™n gia d·ªãch thu·∫≠t game & k·ªπ thu·∫≠t, chuy√™n d·ªãch c√°c ng√¥n ng·ªØ ƒê√¥ng √Å (Nh·∫≠t, Trung, H√†n) sang **ti·∫øng Vi·ªát chu·∫©n t·ª± nhi√™n**.
Ph·∫£i d·ªãch nghƒ©a, kh√¥ng phi√™n √¢m, kh√¥ng gi·ªØ nguy√™n ch·ªØ g·ªëc.
`;

  const userPrompt = `
Translate the following numbered lines into **Vietnamese**, following the glossary and strict rules below.
D·ªãch c√°c d√≤ng ƒë√°nh s·ªë d∆∞·ªõi ƒë√¢y sang **ti·∫øng Vi·ªát** r√µ r√†ng, t·ª± nhi√™n, tu√¢n th·ªß nghi√™m quy t·∫Øc sau:

üìò Glossary (must strictly follow if any match):
${glossText}

Rules / Quy t·∫Øc:
- Always translate fully into Vietnamese.
- Do NOT leave Japanese, Chinese, or Korean text untranslated.
- Do NOT add numbering, notes, or explanations.
- Keep fluent and context-appropriate Vietnamese.
- If the source is an in-game name or technical term, translate the meaning, not pronunciation.
- If a term is untranslatable (e.g. UI, HP, MP), keep it as-is.
${HARD_MODE ? '- Hard Mode: Any untranslated or romanized result is invalid.' : ''}

Now translate:
${text}
`;

  try {
    const r = UrlFetchApp.fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'post',
      headers: {
        Authorization: 'Bearer ' + getApiKey(),
        'Content-Type': 'application/json',
      },
      payload: JSON.stringify({
        model: MODEL,
        messages: [
          { role: 'system', content: systemPrompt.trim() },
          { role: 'user', content: userPrompt.trim() }
        ],
        temperature: 0.1,
      }),
      muteHttpExceptions: true,
    });

    const j = JSON.parse(r.getContentText());
    let output = j.choices?.[0]?.message?.content?.trim() || '';

    // üßπ L√†m s·∫°ch k·∫øt qu·∫£
    output = output
      .replace(/^\d+\.\s*/gm, '') // xo√° numbering
      .replace(/\n{2,}/g, '\n')
      .trim();

    return output;
  } catch (e) {
    Logger.log(e);
    return text;
  }
}

// ====================== 2Ô∏è‚É£ AUTO EXTRACT TERMS (FULL TARGET - REJECT SAFE + PRESERVE MODE) ======================
function autoExtractGlossaryTerms() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const tSheet = ss.getSheetByName('Translations');
  const gSheet = ss.getSheetByName('Glossary');
  const sSheet = ss.getSheetByName('Glossary_Suggestions') || ss.insertSheet('Glossary_Suggestions');

  const data = tSheet.getDataRange().getValues();
  const glossary = gSheet.getDataRange().getValues();
  const suggestionData = sSheet.getDataRange().getValues();

  // üß± Thu th·∫≠p danh s√°ch hi·ªán c√≥
  const existingMap = new Map();
  const rejectedSet = new Set();
  const preservedRows = [suggestionData[0] || ['SourceTerm','TargetTerm','Occurrences','Lang','Status']];

  if (suggestionData.length > 1) {
    for (let i = 1; i < suggestionData.length; i++) {
      const [src,tgt,occ,lang,status] = suggestionData[i];
      if (!src) continue;
      const key = src.toLowerCase().trim();
      existingMap.set(key, [src,tgt,occ,lang,status]);
      if (status && status.toLowerCase() === 'rejected') rejectedSet.add(key);
      // ‚úÖ Gi·ªØ nguy√™n Rejected / Approved
      if (status && ['rejected','approved','verified'].includes(status.toLowerCase()))
        preservedRows.push([src,tgt,occ,lang,status]);
    }
  }

  // üß© Thu th·∫≠p d·ªØ li·ªáu b·∫£n d·ªãch
  const translations = [];
  for (let i = 1; i < data.length; i++) {
    const [_, ctx, orig, tran, status] = data[i];
    if (orig && tran) translations.push({ original: orig, translation: tran });
  }
  if (!translations.length)
    return SpreadsheetApp.getUi().alert('‚ö†Ô∏è No data to extract.');

  // üß† Tr√≠ch xu·∫•t thu·∫≠t ng·ªØ m·ªõi
  const termMap = {};
  for (const pair of translations) {
    const lang = detectLanguage(pair.original);
    const srcTerms = extractCandidateTerms(pair.original);

    for (const term of srcTerms) {
      const key = term.toLowerCase().trim();
      if (rejectedSet.has(key)) continue; // üö´ b·ªè qua n·∫øu ƒë√£ Rejected
      if (!termMap[key]) termMap[key] = { term, lang, translations: [] };
      const frag = extractFullTargetFragment(term, pair.original, pair.translation);
      if (frag) termMap[key].translations.push(frag);
    }
  }

  // üßÆ T·ªïng h·ª£p thu·∫≠t ng·ªØ m·ªõi
  const results = [];
  for (const t of Object.values(termMap)) {
    const candidates = t.translations.filter(Boolean);
    if (candidates.length >= 2) {
      const counts = {};
      for (const c of candidates) counts[c] = (counts[c] || 0) + 1;
      const best = Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
      results.push([t.term,best,candidates.length,t.lang,'Pending']);
    }
  }

  // üß© L·ªçc tr√πng: b·ªè t·ª´ ƒë√£ c√≥ trong Glossary & Suggestion
  const filtered = filterDuplicateGlossaryTerms(results, glossary);
  const final = filtered.filter(r => !existingMap.has(r[0].toLowerCase().trim()));

  // ‚úÖ Ghi l·∫°i, nh∆∞ng gi·ªØ nguy√™n Rejected/Approved c≈©
  const mergedOutput = preservedRows.concat(final);

  sSheet.clear();
  sSheet.getRange(1,1,mergedOutput.length,5).setValues(mergedOutput);

  SpreadsheetApp.getUi().alert(`üìò Added ${final.length} new terms. Preserved ${preservedRows.length-1} existing.`);
}

// üß† Helper: gi·ªØ nguy√™n c·ª•m target
function extractFullTargetFragment(srcTerm, srcText, tgtText) {
  if (!srcTerm || !srcText || !tgtText) return '';
  const src = srcText.toLowerCase();
  const tgt = tgtText.trim();

  const idx = src.indexOf(srcTerm.toLowerCase());
  if (idx === -1) return '';

  // n·∫øu c√≥ c√¢u, tr·∫£ to√†n c√¢u
  if (tgt.includes('„ÄÇ') || tgt.includes('.') || tgt.includes('!') || tgt.includes('ÔºÅ')) {
    const segments = tgt.split(/[„ÄÇ.!ÔºÅ]/).map(s => s.trim()).filter(Boolean);
    return segments.find(s => s.length > 0) || tgt;
  }

  // n·∫øu d·ªãch ng·∫Øn, tr·∫£ to√†n b·∫£n d·ªãch
  if (tgt.length <= 40) return tgt;

  // fallback: l·∫•y ƒëo·∫°n t∆∞∆°ng ·ª©ng kho·∫£ng 40 k√Ω t·ª±
  const posRatio = idx / srcText.length;
  const start = Math.max(0, Math.floor(tgt.length * posRatio) - 15);
  const end = Math.min(tgt.length, start + 40);
  return tgt.substring(start, end).trim();
}

// ====================== 3Ô∏è‚É£ APPROVE / CLEAN / MERGE ======================
function approveSuggestedTerms() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sSheet = ss.getSheetByName('Glossary_Suggestions');
  const gSheet = ss.getSheetByName('Glossary');
  const data = sSheet.getDataRange().getValues();
  const gData = gSheet.getDataRange().getValues();

  const approved = data.filter((r,i)=>i>0 && r[4].toLowerCase()==='approved');
  if (!approved.length) return SpreadsheetApp.getUi().alert('No approved terms.');

  const existing = new Set(gData.slice(1).map(r=>r[0]?.toLowerCase()));
  for (const r of approved) {
    if (!existing.has(r[0].toLowerCase())) gSheet.appendRow([r[0],r[1],'Approved']);
  }
  SpreadsheetApp.getUi().alert(`ü™∂ Added ${approved.length} approved terms.`);
}

function cleanApprovedSuggestions() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Glossary_Suggestions');
  const data = sheet.getDataRange().getValues();
  const remain = [data[0]];
  for (let i = 1; i < data.length; i++) if (data[i][4].toLowerCase() !== 'approved') remain.push(data[i]);
  sheet.clear(); sheet.getRange(1,1,remain.length,5).setValues(remain);
  SpreadsheetApp.getUi().alert('üßΩ Cleaned approved terms.');
}

function handleRejectedTerms() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('Glossary_Suggestions');
  const data = sheet.getDataRange().getValues();
  const remain = [data[0]];
  for (let i = 1; i < data.length; i++) if (data[i][4].toLowerCase() !== 'rejected') remain.push(data[i]);
  sheet.clear(); sheet.getRange(1,1,remain.length,5).setValues(remain);
  SpreadsheetApp.getUi().alert('üß± Removed rejected terms.');
}

function smartMergeGlossary() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const g = ss.getSheetByName('Glossary');
  const data = g.getDataRange().getValues();
  const merged = [data[0]];
  const seen = {};
  for (let i = 1; i < data.length; i++) {
    const [src,tgt,note] = data[i];
    const k = src?.toLowerCase();
    if (!k) continue;
    if (!seen[k]) seen[k] = { src, tgt, note };
    else if (note === 'Approved') seen[k].note = 'Approved';
  }
  for (const k in seen) merged.push([seen[k].src, seen[k].tgt, seen[k].note]);
  g.clear(); g.getRange(1,1,merged.length,3).setValues(merged);
  SpreadsheetApp.getUi().alert('‚úÖ Glossary merged successfully.');
}

// ====================== 4Ô∏è‚É£ HELPERS ======================
function detectLanguage(text){
  if(/[„ÅÅ-„Çì„Ç°-„É¥„Éº]/.test(text)) return 'JP';
  if(/[\u4E00-\u9FFF]/.test(text)) return 'ZH';
  if(/[Í∞Ä-Ìû£]/.test(text)) return 'KO';
  if(/[√Ä-·ªπ]/.test(text)) return 'VI';
  return 'EN';
}
function extractCandidateTerms(text){
  if(!text)return[];
  const en=text.match(/\b[A-Z][a-z]{2,}\b/g)||[];
  const acr=text.match(/\b[A-Z]{2,}\b/g)||[];
  const jp=text.match(/[„ÅÅ-„Çì„Ç°-„É¥„Éº‰∏Ä-ÈæØ]{2,}/g)||[];
  const zh=text.match(/[\u4E00-\u9FFF]{2,}/g)||[];
  const ko=text.match(/[Í∞Ä-Ìû£]{2,}/g)||[];
  const vi=text.match(/[A-Za-z√Ä-·ªπ]{3,}/g)||[];
  return [...new Set([...en,...acr,...jp,...zh,...ko,...vi])];
}
function filterGlossaryForText(gl,text){
  const f=[gl[0]];const lower=text.toLowerCase();
  for(let i=1;i<gl.length;i++){const s=gl[i][0];if(s&&lower.includes(s.toLowerCase()))f.push(gl[i]);}
  return f.length>1?f:[gl[0],...gl.slice(1,16)];
}
function buildGlossaryText(gl){return gl.slice(1).map(r=>`"${r[0]}"‚Üí"${r[1]}"`).join('\n');}
function mockTranslateWithGlossary(t,g){let x=t;for(let i=1;i<g.length;i++){const s=g[i][0],tg=g[i][1];if(s&&tg)x=x.replace(new RegExp(s,'gi'),tg);}return x+' (Mock)';}
function filterDuplicateGlossaryTerms(arr,glo){
  const set=new Set(glo.slice(1).map(r=>r[0]?.toLowerCase().trim()).filter(Boolean));
  return arr.filter(a=>!set.has(a[0].toLowerCase().trim()));
}

// ====================== 5Ô∏è‚É£ MENU ======================
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('üß† AI Translator')
    .addItem('‚ö° Translate Pending Rows','translatePendingRows')
    .addItem('üìò Auto Extract Glossary Terms (Full Target)','autoExtractGlossaryTerms')
    .addSeparator()
    .addItem('ü™∂ Approve Suggested Terms','approveSuggestedTerms')
    .addItem('üßΩ Clean Approved Suggestions','cleanApprovedSuggestions')
    .addItem('üß± Handle Rejected Terms','handleRejectedTerms')
    .addSeparator()
    .addItem('üß© Smart Merge Glossary','smartMergeGlossary')
    .addToUi();
}
